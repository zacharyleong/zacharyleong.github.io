---
interface Props {
  images: Array<{
    src: string;
    alt: string;
    caption?: string;
  }>;
  id?: string;
  transition?: 'fade' | 'slide';
  autoplay?: boolean;
  autoplaySpeed?: number;
  aspectWidth?: number;
  aspectHeight?: number;
  theme?: 'light' | 'dark';
}

const {
  images,
  id = `carousel-${Math.random().toString(36).slice(2)}`,
  transition = 'fade',
  autoplay = false,
  autoplaySpeed = 5000,
  aspectWidth = 16,
  aspectHeight = 9,
  theme = 'light',
} = Astro.props as Props;

const hasMultiple = images.length > 1;
const aspectRatio = `${aspectWidth} / ${aspectHeight}`;
const aspectPadding = `${(aspectHeight / aspectWidth) * 100}%`;
const transitionClass = transition === 'slide' ? 'transition-slide' : 'transition-fade';
const themeClass = theme === 'dark' ? 'theme-dark' : 'theme-light';
---
{images.length === 0 ? (
  <div class="carousel-empty">No images provided.</div>
) : (
  <div
    id={id}
    class={`carousel-container ${transitionClass} ${themeClass}`}
    data-transition={transition}
  >
    <div
      class="carousel-viewport"
      style={{
        '--carousel-aspect-ratio': aspectRatio,
        '--carousel-aspect-padding': aspectPadding,
      }}
    >
      <div class="carousel-viewport-inner">
        <div class="carousel-track">
          {images.map((image, index) => (
            <div
              class={`carousel-slide${index === 0 ? ' active' : ''}`}
              data-index={index}
              data-base="true"
              aria-hidden={index === 0 ? 'false' : 'true'}
            >
              <img
                src={image.src}
                alt={image.alt}
                loading="lazy"
                decoding="async"
                data-caption-text={image.caption ?? image.alt ?? ''}
              />
            </div>
          ))}
        </div>
      </div>

      {hasMultiple && (
        <>
          <button
            class="carousel-control prev"
            type="button"
            aria-label="Previous slide"
            data-action="prev"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="M15.5 5 9 12l6.5 7"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
          <button
            class="carousel-control next"
            type="button"
            aria-label="Next slide"
            data-action="next"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="m8.5 5 6.5 7-6.5 7"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>

          <div class="carousel-indicators" role="tablist">
            {images.map((_, index) => (
              <button
                class={`indicator${index === 0 ? ' active' : ''}`}
                type="button"
                role="tab"
                aria-label={`Go to slide ${index + 1}`}
                aria-selected={index === 0 ? 'true' : 'false'}
                data-indicator={index}
              />
            ))}
          </div>
        </>
      )}
    </div>

    <div class="carousel-caption-container" aria-live="polite">
      {images.map((image, index) => (
        <div
          class={`carousel-caption${index === 0 ? ' active' : ''}`}
          data-caption-index={index}
          aria-hidden={index === 0 ? 'false' : 'true'}
        >
          {image.caption ?? image.alt ?? ''}
        </div>
      ))}
    </div>
  </div>
)}

<script is:inline define:vars={{ id, transition, autoplay, autoplaySpeed, hasMultiple }}>
/* @ts-nocheck */
(() => {
  const init = () => {
    const carousel = document.getElementById(id);
    if (!carousel || carousel.dataset.initialized) return;

    const track = carousel.querySelector('.carousel-track');
    const baseSlides = Array.from(
      carousel.querySelectorAll('.carousel-slide[data-base="true"]'),
    );
    if (!track || baseSlides.length === 0) {
      carousel.dataset.initialized = 'true';
      return;
    }

    const prevBtn = carousel.querySelector('[data-action="prev"]');
    const nextBtn = carousel.querySelector('[data-action="next"]');
    const indicators = Array.from(carousel.querySelectorAll('[data-indicator]'));
    const captions = Array.from(carousel.querySelectorAll('[data-caption-index]'));

    const scheduleFrame =
      typeof window.requestAnimationFrame === 'function'
        ? window.requestAnimationFrame.bind(window)
        : (callback) => window.setTimeout(callback, 16);

    const totalSlides = baseSlides.length;
    const isFade = transition === 'fade';
    const multipleSlides = hasMultiple && totalSlides > 1;
    const autoplayDelay = Math.max(Number(autoplaySpeed) || 0, 1000);
  const fadeDuration = 300;

    let currentIndex = 0;
    let isAnimating = false;
    let autoplayTimer = null;

    carousel.setAttribute('tabindex', '0');

    if (!isFade && multipleSlides) {
      const firstClone = baseSlides[0].cloneNode(true);
      const lastClone = baseSlides[totalSlides - 1].cloneNode(true);
      firstClone.classList.remove('active');
      lastClone.classList.remove('active');
      firstClone.setAttribute('aria-hidden', 'true');
      lastClone.setAttribute('aria-hidden', 'true');
      firstClone.dataset.clone = 'true';
      lastClone.dataset.clone = 'true';
      track.appendChild(firstClone);
      track.insertBefore(lastClone, track.firstChild);
    }

    const renderedSlides = Array.from(track.querySelectorAll('.carousel-slide'));

    const setTrackPosition = (position, options = {}) => {
      if (isFade || !multipleSlides) return;
      const immediate = Boolean(options.immediate);
      if (immediate) {
        track.style.transition = 'none';
      } else {
        track.style.transition = '';
      }
      track.style.transform = `translateX(-${position * 100}%)`;
      if (immediate) {
        void track.offsetWidth;
        track.style.transition = '';
      }
    };

    const updateIndicators = (index) => {
      indicators.forEach((indicator, idx) => {
        const isActiveIndicator = idx === index;
        indicator.classList.toggle('active', isActiveIndicator);
        indicator.setAttribute('aria-selected', isActiveIndicator ? 'true' : 'false');
      });
    };

    const updateCaptions = (index) => {
      captions.forEach((captionNode, idx) => {
        const isActiveCaption = idx === index;
        captionNode.classList.toggle('active', isActiveCaption);
        captionNode.setAttribute('aria-hidden', isActiveCaption ? 'false' : 'true');
      });
    };

    const setSlideActiveForSlideMode = (index) => {
      if (isFade) return;
      baseSlides.forEach((slide, idx) => {
        const isActiveSlide = idx === index;
        slide.classList.toggle('active', isActiveSlide);
        slide.setAttribute('aria-hidden', isActiveSlide ? 'false' : 'true');
      });
    };

    if (isFade) {
      baseSlides.forEach((slide, idx) => {
        const isActiveSlide = idx === 0;
        slide.classList.toggle('active', isActiveSlide);
        slide.classList.remove('incoming');
        slide.classList.remove('fade-underneath');
        slide.setAttribute('aria-hidden', isActiveSlide ? 'false' : 'true');
      });
    } else {
      setSlideActiveForSlideMode(currentIndex);
      setTrackPosition(currentIndex + 1, { immediate: true });
    }

    updateIndicators(currentIndex);
    updateCaptions(currentIndex);

    const stopAutoplay = () => {
      if (autoplayTimer) {
        window.clearInterval(autoplayTimer);
        autoplayTimer = null;
      }
    };

    const startAutoplay = () => {
      if (!autoplay || !multipleSlides) return;
      stopAutoplay();
      autoplayTimer = window.setInterval(() => {
        if (!isAnimating) {
          goToSlide(currentIndex + 1, { direction: 1, force: true });
        }
      }, autoplayDelay);
    };

    const goToSlide = (requestedIndex, options = {}) => {
      if (!multipleSlides) return;

      const normalizedTarget = ((requestedIndex % totalSlides) + totalSlides) % totalSlides;
      if (!options.force && normalizedTarget === currentIndex) return;

      stopAutoplay();

      if (isFade) {
        if (isAnimating) return;
        const previousIndex = currentIndex;
        if (previousIndex === normalizedTarget) {
          startAutoplay();
          return;
        }

        const nextSlide = baseSlides[normalizedTarget];
        const prevSlide = baseSlides[previousIndex];

        if (!nextSlide) {
          startAutoplay();
          return;
        }

        isAnimating = true;
        currentIndex = normalizedTarget;
        updateIndicators(currentIndex);
        updateCaptions(currentIndex);

        if (prevSlide && prevSlide !== nextSlide) {
          prevSlide.classList.add('fade-underneath');
          prevSlide.setAttribute('aria-hidden', 'true');
        }

        nextSlide.classList.add('incoming');
        nextSlide.setAttribute('aria-hidden', 'false');

        scheduleFrame(() => {
          nextSlide.classList.add('active');
        });

        let fadeCompleted = false;
        let fallbackTimer = null;

        const cleanup = () => {
          if (fadeCompleted) return;
          fadeCompleted = true;

          if (fallbackTimer !== null) {
            window.clearTimeout(fallbackTimer);
            fallbackTimer = null;
          }

          nextSlide.classList.remove('incoming');
          if (prevSlide && prevSlide !== nextSlide) {
            prevSlide.classList.remove('fade-underneath');
            prevSlide.classList.remove('active');
            prevSlide.setAttribute('aria-hidden', 'true');
          }
          isAnimating = false;
          startAutoplay();
        };

        const handleTransitionEnd = (event) => {
          if (event.target !== nextSlide || event.propertyName !== 'opacity') return;
          nextSlide.removeEventListener('transitionend', handleTransitionEnd);
          cleanup();
        };

        nextSlide.addEventListener('transitionend', handleTransitionEnd);

        fallbackTimer = window.setTimeout(() => {
          nextSlide.removeEventListener('transitionend', handleTransitionEnd);
          cleanup();
        }, fadeDuration + 150);

        return;
      }

      if (isAnimating) return;
      isAnimating = true;

      const previousIndex = currentIndex;
      const direction =
        typeof options.direction === 'number' && options.direction !== 0
          ? options.direction
          : requestedIndex > previousIndex
          ? 1
          : -1;

      let targetPosition = normalizedTarget + 1;
      let wrapReset = null;

      if (direction > 0 && previousIndex === totalSlides - 1 && normalizedTarget === 0) {
        targetPosition = totalSlides + 1;
        wrapReset = { index: 0, position: 1 };
      } else if (direction < 0 && previousIndex === 0 && normalizedTarget === totalSlides - 1) {
        targetPosition = 0;
        wrapReset = { index: totalSlides - 1, position: totalSlides };
      }

      currentIndex = normalizedTarget;
      updateIndicators(currentIndex);
      updateCaptions(currentIndex);
      setSlideActiveForSlideMode(currentIndex);
      setTrackPosition(targetPosition, { immediate: false });

      const handleTransitionEnd = (event) => {
        if (event.target !== track || event.propertyName !== 'transform') return;
        track.removeEventListener('transitionend', handleTransitionEnd);

        if (wrapReset) {
          setTrackPosition(wrapReset.position, { immediate: true });
          currentIndex = wrapReset.index;
          updateIndicators(currentIndex);
          updateCaptions(currentIndex);
          setSlideActiveForSlideMode(currentIndex);
        }

        isAnimating = false;
        startAutoplay();
      };

      track.addEventListener('transitionend', handleTransitionEnd);
    };

    const openLightbox = (startIndex) => {
      if (!window.mediumZoom) return;

      // Initialize medium-zoom on first use with only base slide images (no clones)
      if (!carousel._mediumZoom) {
        const baseImages = baseSlides.map(slide => slide.querySelector('img')).filter(Boolean);
        
        carousel._mediumZoom = window.mediumZoom(baseImages, {
          margin: 48,
          background: 'rgba(0, 0, 0, 0.80)',
          scrollOffset: 0,
        });
      }

      // Get the base slide image at the current index
      const targetSlide = baseSlides[startIndex];
      if (!targetSlide) return;
      
      const img = targetSlide.querySelector('img');
      if (!img) return;

      // Trigger zoom on the specific base slide image
      carousel._mediumZoom.open({ target: img });
    };

    if (multipleSlides && prevBtn) {
      prevBtn.addEventListener('click', () =>
        goToSlide(currentIndex - 1, { direction: -1, force: true }),
      );
    }

    if (multipleSlides && nextBtn) {
      nextBtn.addEventListener('click', () =>
        goToSlide(currentIndex + 1, { direction: 1, force: true }),
      );
    }

    indicators.forEach((indicator, idx) => {
      indicator.addEventListener('click', (event) => {
        event.preventDefault();
        if (isAnimating || idx === currentIndex) return;
        const directionGuess = idx > currentIndex ? 1 : -1;
        goToSlide(idx, { direction: directionGuess, force: true });
      });
    });

    carousel.addEventListener('keydown', (event) => {
      if (!multipleSlides) return;
      if (event.key === 'ArrowLeft') {
        goToSlide(currentIndex - 1, { direction: -1, force: true });
      } else if (event.key === 'ArrowRight') {
        goToSlide(currentIndex + 1, { direction: 1, force: true });
      }
    });

    renderedSlides.forEach((slide) => {
      slide.addEventListener('click', () => {
        const indexAttr = slide.getAttribute('data-index');
        const startIndex = Number(indexAttr || 0);
        openLightbox(Number.isNaN(startIndex) ? 0 : startIndex);
      });
    });

    if (autoplay && multipleSlides) {
      carousel.addEventListener('mouseenter', stopAutoplay);
      carousel.addEventListener('mouseleave', startAutoplay);
      carousel.addEventListener('focusin', stopAutoplay);
      carousel.addEventListener('focusout', startAutoplay);

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          stopAutoplay();
        } else {
          startAutoplay();
        }
      });
    }

    startAutoplay();
    carousel.dataset.initialized = 'true';
  };

  if (typeof window !== 'undefined') {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => window.setTimeout(init, 100));
    } else {
      window.setTimeout(init, 100);
    }
  }
})();
</script>

<script is:inline>
  if (!window.mediumZoomLoaded) {
    window.mediumZoomLoaded = true;
    
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js';
    script.onerror = () => {
      console.error('Failed to load medium-zoom');
    };
    document.head.appendChild(script);
  }
</script>

<style>
  /* Ensure medium-zoom appears above everything */
  :global(.medium-zoom-overlay) {
    z-index: 10000 !important;
  }

  :global(.medium-zoom-image--opened) {
    z-index: 10001 !important;
  }

  .carousel-container {
    position: relative;
    width: 100%;
    margin: 2rem 0;
    display: flex;
    flex-direction: column;
    background: transparent;
    border: none;
  --carousel-arrow-color: rgba(20, 20, 20, 0.75);
  --carousel-arrow-hover: rgba(20, 20, 20, 1);
  --carousel-indicator-active: rgba(20, 20, 20, 0.9);
  --carousel-indicator-inactive: rgba(20, 20, 20, 0.35);
  --carousel-caption-color: #666666;
    --carousel-background: rgba(255, 255, 255, 0);
  }

  .carousel-container.theme-dark {
  --carousel-arrow-color: rgba(255, 255, 255, 0.78);
  --carousel-arrow-hover: rgba(255, 255, 255, 1);
  --carousel-indicator-active: rgba(255, 255, 255, 0.92);
  --carousel-indicator-inactive: rgba(255, 255, 255, 0.4);
  --carousel-caption-color: #666666;
  --carousel-background: rgba(0, 0, 0, 0.55);
  }

  .carousel-viewport {
    position: relative;
    width: 100%;
    overflow: hidden;
    background: var(--carousel-background);
    aspect-ratio: var(--carousel-aspect-ratio);
    border-radius: inherit;
  }

  .carousel-viewport::before {
    content: '';
    display: block;
    padding-top: var(--carousel-aspect-padding);
  }

  @supports (aspect-ratio: 1 / 1) {
    .carousel-viewport::before {
      display: none;
    }
  }

  .carousel-viewport-inner {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  .carousel-track {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  .carousel-container.transition-slide .carousel-track {
    display: flex;
    transition: transform 0.3s ease;
  }

  .carousel-container.transition-fade .carousel-track {
    position: absolute;
  }

  .carousel-slide {
    width: 100%;
    height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  }

  .carousel-container.transition-slide .carousel-slide {
    flex: 0 0 100%;
    pointer-events: none;
  }

  .carousel-container.transition-slide .carousel-slide.active {
    pointer-events: auto;
  }

  .carousel-container.transition-fade .carousel-slide {
    position: absolute;
    inset: 0;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s linear;
    z-index: 1;
  }

  .carousel-container.transition-fade .carousel-slide.incoming {
    z-index: 3;
  }

  .carousel-container.transition-fade .carousel-slide.active {
    opacity: 1;
    pointer-events: auto;
    z-index: 4;
  }

  .carousel-container.transition-fade .carousel-slide.fade-underneath {
    opacity: 1;
    pointer-events: none;
    z-index: 2;
  }

  .carousel-slide img {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    object-fit: contain;
    cursor: zoom-in;
    user-select: none;
    background-color: transparent;
  }

  .carousel-control {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 3rem;
    background: transparent;
    border: none;
    color: var(--carousel-arrow-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s ease, transform 0.2s ease;
    z-index: 8;
    padding: 0;
  }

  .carousel-control:hover,
  .carousel-control:focus-visible {
    color: var(--carousel-arrow-hover);
    transform: scale(1.05);
  }

  .carousel-control svg {
    width: 1.75rem;
    height: 1.75rem;
  }

  .carousel-control.prev {
    left: 0;
  }

  .carousel-control.next {
    right: 0;
  }

  .carousel-indicators {
    position: absolute;
    bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 0.5rem;
    z-index: 5;
  }

  .indicator {
    width: 0.5rem;
    height: 0.5rem;
    border-radius: 999px;
    border: none;
    background: var(--carousel-indicator-inactive);
    padding: 0;
    cursor: pointer;
    transition: background 0.2s ease, width 0.2s ease;
  }

  .indicator.active {
    width: 1.3rem;
    background: var(--carousel-indicator-active);
  }

  .carousel-caption-container {
    position: relative;
    margin-top: 0.75rem;
    min-height: 1.75rem;
  }

  .carousel-caption {
    position: absolute;
    inset: 0;
    opacity: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: var(--carousel-caption-color);
    transition: opacity 0.3s linear;
    pointer-events: none;
    z-index: 1;
  }

  .carousel-caption.active {
    opacity: 1;
    pointer-events: auto;
    z-index: 2;
  }

  .carousel-empty {
    padding: 1.5rem;
    text-align: center;
  color: #666666;
  }
</style>
